#ifndef CoCoA_ideal_H
#define CoCoA_ideal_H

//   Copyright (c)  2003-2010  John Abbott,  Anna M. Bigatti

//   This file is part of the source of CoCoALib, the CoCoA Library.
//
//   CoCoALib is free software: you can redistribute it and/or modify
//   it under the terms of the GNU General Public License as published by
//   the Free Software Foundation, either version 3 of the License, or
//   (at your option) any later version.
//
//   CoCoALib is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//   GNU General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   along with CoCoALib.  If not, see <http://www.gnu.org/licenses/>.


// Header file for the abstract class ideal


#include "CoCoA/ring.H"
#include "CoCoA/bool3.H"
#include "CoCoA/CpuTimeLimit.H"
#include "CoCoA/SmartPtrIRC.H"
#include "CoCoA/utils.H" // for len

#include <cstddef>
//using std::size_t;
#include <iosfwd>
//using std::ostream;
#include <vector>
//using std::vector;

namespace CoCoA
{

  class OpenMathOutput; // fwd decl -- defined in OpenMath.H
  class IdealBase;      // fwd decl -- defined later in this file

  class ideal
  {
  public:
    explicit ideal(IdealBase* IPtr);    //??? public???
    explicit ideal(ConstRefRingElem r);                      // make a principal ideal
    ideal(ConstRefRingElem r1, ConstRefRingElem r2);
    ideal(ConstRefRingElem r1, ConstRefRingElem r2, ConstRefRingElem r3);
    ideal(ConstRefRingElem r1, ConstRefRingElem r2, ConstRefRingElem r3, ConstRefRingElem r4);
    explicit ideal(const std::vector<RingElem>& gens);       // make the ideal gen'd by gens !={}
    ideal(const ring& R, const std::vector<RingElem>& gens); // make the ideal generated by gens
    ideal(const ideal& copy);
    ideal& operator=(const ideal& rhs);
    ~ideal();

    const IdealBase* myIdealPtr() const;
//???    IdealBase* operator->();              // allow non-const member fns to be called
    const IdealBase* operator->() const;  // allow const member fns to be called
  private:
    IdealBase* myPtr;
    friend IdealBase* MakeUnique(ideal& I);
  };

//   class IdealBase; // fwd decl, defn immediately below.
//   typedef SmartPtrIRC<const IdealBase> ideal;  //???? const???

  class IdealBase  //???: protected IntrusiveReferenceCount
  {
  protected: // ref count accessible only to friends and derived classes.
    friend class ideal;
    friend IdealBase* MakeUnique(ideal& I); // so it can call RefCountIsOne
    mutable std::size_t myRefCount; // every ideal has an intrusive reference count
    void myRefCountInc() const;
    void myRefCountDec() const;
    bool myRefCountIsOne() const;

    //--- member fields -----------------------------------
    // NB these flags are NOT INDEPENDENT
    // (because maximality implies primality, etc.)
  protected:
    mutable bool3 IamMaximal3Flag;
    mutable bool3 IamPrimary3Flag;
    mutable bool3 IamPrime3Flag;
    mutable bool3 IamRadical3Flag;

  protected:
    IdealBase(): myRefCount(0) {};
    virtual ~IdealBase();

  public:
    virtual IdealBase* myClone() const = 0;
//???    virtual void swap(ideal& other) = 0;

    virtual const ring& myRing() const = 0;
    virtual bool IamZero() const = 0;
    virtual bool IamOne() const;                 ///< virtual + default impl

    virtual bool IhaveElem(RingElemConstRawPtr rawx) const = 0;
    bool3 IamMaximal3() const { return IamMaximal3Flag; }
    bool3 IamPrimary3() const { return IamPrimary3Flag; }
    bool3 IamPrime3() const   { return IamPrime3Flag; }
    bool3 IamRadical3() const { return IamRadical3Flag; }
    bool IamMaximal() const;
    bool IamPrimary() const;
    bool IamPrime() const;
    bool IamRadical() const;
    virtual bool myAssignMaximalFlag(bool b) const; ///< virtual + default impl
    virtual bool myAssignPrimaryFlag(bool b) const; ///< virtual + default impl
    virtual bool myAssignPrimeFlag(bool b) const;   ///< virtual + default impl
    virtual bool myAssignRadicalFlag(bool b) const; ///< virtual + default impl

    virtual void myReduceMod(RingElemRawPtr rawx) const = 0; ///< r elem of R, where I is ideal in R
    virtual void myAdd(const ideal&) = 0;
    virtual void myMul(const ideal&) = 0;
    virtual void myIntersect(const ideal&) = 0;
    virtual void myColon(const ideal&) = 0;
    virtual void mySaturate(const ideal&);
    //    virtual void myElim(const std::vector<RingElem>& v); // default: error
    virtual void myAssignElim(const ideal& I, const std::vector<RingElem>& v); // default: error
    virtual void myMinimalize(); // default: error
    virtual bool myDivMod(RingElemRawPtr rawlhs, RingElemConstRawPtr rawnum, RingElemConstRawPtr rawden) const = 0; // result is true iff result exists & is unique (mod I); set lhs = num/den modulo I (iff result is true)

    virtual const std::vector<RingElem>& myGens() const = 0; // gens not quite as specified by user #1647
    virtual const std::vector<RingElem>& myTidyGens(const CpuTimeLimit& CheckForTimeout) const = 0; // tidier set of gens
    virtual std::vector<ideal> myPrimaryDecomposition() const; ///< virtual + default impl

    virtual void myOutputSelf(std::ostream& out) const;
    virtual void myOutputSelf_OM(OpenMathOutput& OMOut) const;

  protected: // assign relevant flag  accordingly, may also set other flags
    virtual void myTestIsMaximal() const = 0;
    virtual void myTestIsPrimary() const = 0;
    virtual void myTestIsPrime() const = 0;
    virtual void myTestIsRadical() const = 0;
};


  RingElem operator%(const MachineInt& n, const ideal& I);///< reduce n modulo I
  RingElem operator%(const BigInt& N, const ideal& I);    ///< reduce N modulo I
  RingElem operator%(const BigRat& Q, const ideal& I);    ///< reduce N modulo I
  RingElem operator%(ConstRefRingElem r, const ideal& I); ///< reduce r modulo I
  RingElem NF(ConstRefRingElem r, const ideal& I); ///< reduce r modulo I, same as %

//???  ideal operator*(const MachineInt& n, const ideal& I);
//???  ideal operator*(const BigInt& N, const ideal& I);
//???  ideal operator*(const BigRat& q, const ideal& I);
  ideal operator*(ConstRefRingElem r, const ideal& I);
//???  ideal operator*(const ideal& I, const MachineInt& n);
//???  ideal operator*(const ideal& I, const BigInt& N);
//???  ideal operator*(const ideal& I, const BigRat& q);
  ideal operator*(const ideal& I, ConstRefRingElem r);
  ideal operator+(const ideal& I, const ideal& J);
  ideal operator*(const ideal& I, const ideal& J);
  ideal& operator+=(ideal& I, const ideal& J);
  ideal& operator*=(ideal& I, const ideal& J);
  ideal power(const ideal& I, const MachineInt& n);
  ideal power(const ideal& I, const BigInt& N);

  ideal intersect(const ideal& I, const ideal& J);
  ideal colon(const ideal& I, const ideal& J);
  ideal saturate(const ideal& I, const ideal& J);
  bool IsContained(const ideal& I, const ideal& J);  // Is ideal I contained in ideal J?
  bool operator==(const ideal& I, const ideal& J);
  inline bool operator!=(const ideal& I, const ideal& J) { return !(I==J); }
  bool IsElem(ConstRefRingElem r, const ideal& I);
  bool IsElem(const BigInt& r, const ideal& I);
  bool IsElem(const BigRat& r, const ideal& I);
  bool IsElem(const MachineInt& r, const ideal& I);
  std::ostream& operator<<(std::ostream& out, const ideal& I);
  OpenMathOutput& operator<<(OpenMathOutput& OMOut, const ideal& I);

  //---------------------------------------------------------------------------
  // Inline functions

  inline void IdealBase::myRefCountInc() const { ++myRefCount; }
  inline void IdealBase::myRefCountDec() const { if (--myRefCount == 0) delete this; }
  inline bool IdealBase::myRefCountIsOne() const { return myRefCount == 1; }


  inline const IdealBase* ideal::myIdealPtr() const
  { return myPtr; }


//   inline IdealBase* ideal::operator->()              // allow non-const member fns to be called
//   {
//     CoCoA_ASSERT(myPtr->RefCountIsOne());
//     return myPtr;
//   }


  inline const IdealBase* ideal::operator->() const  // allow const member fns to be called
  { return myPtr; }


  inline bool IsZero(const ideal& I)    { return I->IamZero(); }
  inline bool IsOne(const ideal& I)     { return I->IamOne(); }
  inline bool IsMaximal(const ideal& I) { return I->IamMaximal(); }
  inline bool IsPrimary(const ideal& I) { return I->IamPrimary(); }
  inline bool IsPrime(const ideal& I)   { return I->IamPrime(); }
  inline bool IsRadical_tmp(const ideal& I) { return I->IamRadical(); }
  inline bool3 IsMaximal3(const ideal& I) { return I->IamMaximal3(); }
  inline bool3 IsPrimary3(const ideal& I)   { return I->IamPrimary3(); }
  inline bool3 IsPrime3(const ideal& I)   { return I->IamPrime3(); }
  inline bool3 IsRadical3(const ideal& I)   { return I->IamRadical3(); }
  inline long NumGens(const ideal& I) { return len(I->myGens()); }
  inline const std::vector<RingElem>& gens(const ideal& I) { return I->myGens();}
  inline const std::vector<RingElem>& TidyGens(const ideal& I) { return I->myTidyGens(NoCpuTimeLimit()); }
  inline const std::vector<RingElem>& TidyGens(const ideal& I, const CpuTimeLimit& CheckForTimeout) { return I->myTidyGens(CheckForTimeout); }
  inline const ring& RingOf(const ideal& I) { return I->myRing(); }
  inline RingElem NF(ConstRefRingElem r, const ideal& I) { return r%I; }
  inline std::vector<ideal> PrimaryDecomposition(const ideal& I) { return I->myPrimaryDecomposition(); }


} // end of namespace CoCoA

#endif
